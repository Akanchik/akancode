<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>AKANCODE –û–Ω–ª–∞–π–Ω</title>
  <style>
    body {
      font-family: monospace;
      background: #1e1e1e;
      color: #cfcfcf;
      margin: 20px;
    }
    textarea {
      width: 100%;
      height: 180px;
      background: #2d2d2d;
      color: #eee;
      border: none;
      padding: 10px;
      font-size: 16px;
      resize: vertical;
    }
    #output {
      white-space: pre-wrap;
      margin-top: 15px;
      background: #111;
      padding: 10px;
      min-height: 100px;
      border-radius: 5px;
      max-height: 300px;
      overflow-y: auto;
    }
    button {
      margin: 5px 5px 5px 0;
      padding: 8px 16px;
      font-size: 14px;
      background: #e69138;
      border: none;
      color: white;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background: #e48a2c;
    }
    .menu-bar {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    .dropdown {
      position: relative;
      display: inline-block;
    }
    .dropdown-content {
      display: none;
      position: absolute;
      background-color: #333;
      min-width: 120px;
      z-index: 1;
      border: 1px solid #555;
    }
    .dropdown-content button {
      width: 100%;
      text-align: left;
      background: none;
      border: none;
      color: white;
      padding: 8px;
      cursor: pointer;
    }
    .dropdown:hover .dropdown-content {
      display: block;
    }
    #ui button {
      margin: 5px;
    }
  </style>
</head>
<body>

  <h1>AKANCODE</h1>

  <div class="menu-bar">
    <div class="dropdown">
      <button>–§–∞–π–ª</button>
      <div class="dropdown-content">
        <button onclick="saveFile()">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
        <button onclick="loadFile()">–ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
        <input type="file" id="fileInput" style="display:none" onchange="handleFile(this.files)" />
      </div>
    </div>
    <button onclick="clearCode()">–û—á–∏—Å—Ç–∏—Ç—å –∫–æ–¥</button>
    <button onclick="clearOutput()">–û—á–∏—Å—Ç–∏—Ç—å –≤—ã–≤–æ–¥</button>
    <button onclick="showHelp()">–°–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥</button>
    <button onclick="resetInterpreter()">–°–±—Ä–æ—Å–∏—Ç—å –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä</button>
  </div>

  <textarea id="code" spellcheck="false" placeholder="–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –∫–æ–¥ AKANCODE –∑–¥–µ—Å—å..."></textarea>
  <br>
  <button onclick="runCode()">–ó–∞–ø—É—Å—Ç–∏—Ç—å</button>
  <button onclick="openAsSite()">–û—Ç–∫—Ä—ã—Ç—å –∫–∞–∫ —Å–∞–π—Ç</button>
  <h5>V0.2.0 BETA</h5>

  <div id="output"></div>
  <div id="ui" style="margin-top: 20px;"></div>

<script>
const outputDiv = document.getElementById("output");
const fileInput = document.getElementById("fileInput");
const uiDiv = document.getElementById("ui");
let –∫–Ω–æ–ø–∫–∏–ù–∞–∂–∞—Ç—ã = {};
let isRunning = false;
let variables = {};
let labels = {};
let arrays = {};
let currentLine = 0;
let rawCode = [];
let executionTimeout = null;

function resetInterpreter() {
  if (executionTimeout) {
    clearTimeout(executionTimeout);
    executionTimeout = null;
  }
  
  isRunning = false;
  –∫–Ω–æ–ø–∫–∏–ù–∞–∂–∞—Ç—ã = {};
  variables = {};
  labels = {};
  arrays = {};
  currentLine = 0;
  rawCode = [];
  
  outputDiv.innerHTML = "";
  uiDiv.innerHTML = "";
}

function clearCode() {
  document.getElementById("code").value = "";
}

function clearOutput() {
  outputDiv.innerHTML = "";
  uiDiv.innerHTML = "";
  –∫–Ω–æ–ø–∫–∏–ù–∞–∂–∞—Ç—ã = {};
}

function showHelp() {
  alert(`–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã AKANCODE:

üìä –û–°–ù–û–í–ù–´–ï –ö–û–ú–ê–ù–î–´:
  –í–í–û–î –∏–º—è              - –í–≤–æ–¥ –∑–Ω–∞—á–µ–Ω–∏—è
  –ü–†–ò–°–í–û–ò–¢–¨ –∏–º—è = –∑–Ω–∞—á–µ–Ω–∏–µ - –ü—Ä–∏—Å–≤–æ–µ–Ω–∏–µ
  –í–´–í–ï–°–¢–ò –≤—ã—Ä–∞–∂–µ–Ω–∏–µ     - –í—ã–≤–æ–¥
  –ü–ï–ß–ê–¢–ê–¢–¨ "—Ç–µ–∫—Å—Ç"      - –ü–µ—á–∞—Ç—å –ø–æ –±—É–∫–≤–∞–º

üî¢ –ú–ê–¢–ï–ú–ê–¢–ò–ß–ï–°–ö–ò–ï:
  –°–õ–û–ñ–ò–¢–¨ a b —Ä–µ–∑—É–ª—å—Ç–∞—Ç
  –í–´–ß–ï–°–¢–¨ a b —Ä–µ–∑—É–ª—å—Ç–∞—Ç
  –£–ú–ù–û–ñ–ò–¢–¨ a b —Ä–µ–∑—É–ª—å—Ç–∞—Ç
  –î–ï–õ–ò–¢–¨ a b —Ä–µ–∑—É–ª—å—Ç–∞—Ç
  –°–õ–£–ß–ê–ô–ù–û –º–∏–Ω –º–∞–∫—Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç
  –û–°–¢–ê–¢–û–ö a b —Ä–µ–∑—É–ª—å—Ç–∞—Ç
  –°–¢–ï–ü–ï–ù–¨ a b —Ä–µ–∑—É–ª—å—Ç–∞—Ç

üîÑ –£–°–õ–û–í–ò–Ø –ò –¶–ò–ö–õ–´:
  –ï–°–õ–ò —É—Å–ª–æ–≤–∏–µ –¢–û –∫–æ–º–∞–Ω–¥–∞
  –ü–û–ö–ê —É—Å–ª–æ–≤–∏–µ –í–´–ü–û–õ–ù–Ø–¢–¨
  –î–õ–Ø i=1 –î–û 10 –í–´–ü–û–õ–ù–Ø–¢–¨
  –ü–†–ï–†–í–ê–¢–¨              - –í—ã—Ö–æ–¥ –∏–∑ —Ü–∏–∫–ª–∞
  –ü–†–û–î–û–õ–ñ–ò–¢–¨           - –°–ª–µ–¥—É—é—â–∞—è –∏—Ç–µ—Ä–∞—Ü–∏—è

üì¶ –ú–ê–°–°–ò–í–´:
  –ú–ê–°–°–ò–í –∏–º—è[—Ä–∞–∑–º–µ—Ä]
  –ó–ê–ü–ò–°–ê–¢–¨ –∏–º—è[–∏–Ω–¥–µ–∫—Å] = –∑–Ω–∞—á–µ–Ω–∏–µ
  –ü–†–û–ß–ï–°–¢–¨ –∏–º—è[–∏–Ω–¥–µ–∫—Å] —Ä–µ–∑—É–ª—å—Ç–∞—Ç
  –î–õ–ò–ù–ê –∏–º—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç

üè∑Ô∏è –ú–ï–¢–ö–ò –ò –ü–ï–†–ï–•–û–î–´:
  –ú–ï–¢–ö–ê –∏–º—è
  –ü–ï–†–ï–ô–¢–ò –∏–º—è
  –í–´–ó–í–ê–¢–¨ –∏–º—è          - –í—ã–∑–æ–≤ –ø–æ–¥–ø—Ä–æ–≥—Ä–∞–º–º—ã
  –í–ï–†–ù–£–¢–¨              - –í–æ–∑–≤—Ä–∞—Ç –∏–∑ –ø–æ–¥–ø—Ä–æ–≥—Ä–∞–º–º—ã

üéÆ –ò–ì–†–´:
  –ò–ì–†–ê –£–ì–ê–î–ê–ô
  –ò–ì–†–ê –ö–ù–ë             - –ö–∞–º–µ–Ω—å-–Ω–æ–∂–Ω–∏—Ü—ã-–±—É–º–∞–≥–∞

üé® –ò–ù–¢–ï–†–§–ï–ô–°:
  –ó–ê–ì–û–õ–û–í–û–ö "—Ç–µ–∫—Å—Ç"
  –¢–ï–ö–°–¢ "—Ç–µ–∫—Å—Ç"
  –ö–ù–û–ü–ö–ê –∏–º—è "—Ç–µ–∫—Å—Ç"
  –ü–û–õ–ï_–í–í–û–î–ê –∏–º—è "–ø–æ–¥—Å–∫–∞–∑–∫–∞"
  –ï–°–õ–ò_–ù–ê–ñ–ê–¢–ê –∏–º—è –¢–û –∫–æ–º–∞–Ω–¥–∞

‚è∞ –°–ò–°–¢–ï–ú–ù–´–ï:
  –ü–ê–£–ó–ê –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥—ã    - –ü–∞—É–∑–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
  –°–õ–£–ß–ê–ô–ù–û–ï_–ß–ò–°–õ–û —Ä–µ–∑—É–ª—å—Ç–∞—Ç
  –¢–ï–ö–£–©–ï–ï_–í–†–ï–ú–Ø —Ä–µ–∑—É–ª—å—Ç–∞—Ç

üìù –ö–û–ú–ú–ï–ù–¢–ê–†–ò–ò:
  // –û–¥–Ω–æ—Å—Ç—Ä–æ—á–Ω—ã–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π
  /* –ú–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω—ã–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π */`);
}

function saveFile() {
  const blob = new Blob([document.getElementById("code").value], { type: "text/plain" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "script.ak";
  a.click();
}

function loadFile() {
  fileInput.click();
}

function handleFile(files) {
  const reader = new FileReader();
  reader.onload = e => {
    document.getElementById("code").value = e.target.result;
  };
  reader.readAsText(files[0]);
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function –ø–µ—á–∞—Ç—å_–ø–æ_–±—É–∫–≤–∞–º(text, delay = 30) {
  for (let i = 0; i < text.length; i++) {
    outputDiv.innerHTML += text[i];
    await sleep(delay);
  }
  outputDiv.innerHTML += "<br>";
}

function parseLine(line) {
  return line.trim().split('"').reduce((result, part, i) => {
    if (i % 2 === 0) {
      return result.concat(part.trim().split(/\s+/).filter(Boolean));
    } else {
      return result.concat(part);
    }
  }, []).filter(Boolean);
}

async function executeLine(line) {
  if (!line || line.startsWith("#") || line.startsWith("//") || line.startsWith("/*")) {
    return true;
  }

  const parts = parseLine(line);
  if (parts.length === 0) return true;

  const cmd = parts[0];

  try {
    // ========== –°–£–©–ï–°–¢–í–£–Æ–©–ò–ï –ö–û–ú–ê–ù–î–´ ==========
    if (cmd === "–í–í–û–î") {
      if (parts.length < 2) return true;
      let varName = parts[1];
      let val = prompt(`–í–≤–µ–¥–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è ${varName}:`);
      val = isNaN(parseInt(val)) ? val : parseInt(val);
      variables[varName] = val;
    } else if (cmd === "–ü–†–ò–°–í–û–ò–¢–¨") {
      if (parts.length < 4) return true;
      let varName = parts[1];
      if (parts[2] === "=") {
        let val = parts.slice(3).join(" ");
        val = val.replace(/^"|"$/g, "");
        val = isNaN(parseInt(val)) ? (variables[val] ?? val) : parseInt(val);
        variables[varName] = val;
      }
    } else if (cmd === "–°–õ–û–ñ–ò–¢–¨") {
      if (parts.length < 4) return true;
      let resultVar = parts[parts.length - 1];
      let total = 0;
      for (let v of parts.slice(1, -1)) {
        let val = variables[v];
        if (val === undefined) val = parseInt(v) || 0;
        total += parseInt(val);
      }
      variables[resultVar] = total;
    } else if (cmd === "–í–´–ß–ï–°–¢–¨") {
      if (parts.length < 4) return true;
      let a = variables[parts[1]] ?? parseInt(parts[1]) ?? 0;
      let b = variables[parts[2]] ?? parseInt(parts[2]) ?? 0;
      variables[parts[3]] = a - b;
    } else if (cmd === "–£–ú–ù–û–ñ–ò–¢–¨") {
      if (parts.length < 4) return true;
      let a = variables[parts[1]] ?? parseInt(parts[1]) ?? 0;
      let b = variables[parts[2]] ?? parseInt(parts[2]) ?? 0;
      variables[parts[3]] = a * b;
    } else if (cmd === "–î–ï–õ–ò–¢–¨") {
      if (parts.length < 4) return true;
      let a = variables[parts[1]] ?? parseInt(parts[1]) ?? 0;
      let b = variables[parts[2]] ?? parseInt(parts[2]) ?? 1;
      variables[parts[3]] = b !== 0 ? a / b : "–û—à–∏–±–∫–∞: –¥–µ–ª–µ–Ω–∏–µ –Ω–∞ 0";
    } else if (cmd === "–°–õ–£–ß–ê–ô–ù–û") {
      if (parts.length < 4) return true;
      let a = variables[parts[1]] ?? parseInt(parts[1]);
      let b = variables[parts[2]] ?? parseInt(parts[2]);
      variables[parts[3]] = Math.floor(Math.random() * (b - a + 1)) + a;
    } else if (cmd === "–í–´–í–ï–°–¢–ò") {
      if (parts.length < 2) return true;
      let expr = parts.slice(1).join(" ");
      expr = expr.trim();
      if (expr.startsWith('"') && expr.endsWith('"')) {
        outputDiv.innerHTML += expr.slice(1, -1) + "<br>";
      } else {
        let val = variables[expr] ?? expr;
        outputDiv.innerHTML += val + "<br>";
      }
    } else if (cmd === "–ü–ï–ß–ê–¢–ê–¢–¨") {
      if (parts.length < 2) return true;
      let text = parts.slice(1).join(" ");
      if (text.startsWith('"') && text.endsWith('"')) {
        await –ø–µ—á–∞—Ç—å_–ø–æ_–±—É–∫–≤–∞–º(text.slice(1, -1));
      } else {
        let val = variables[text] ?? text;
        await –ø–µ—á–∞—Ç—å_–ø–æ_–±—É–∫–≤–∞–º(val);
      }
    } else if (cmd === "–ï–°–õ–ò") {
      if (parts.length < 6) return true;
      let conditionVar1 = parts[1];
      let conditionOp = parts[2];
      let conditionVar2 = parts[3];
      let thenCmd = parts[4];
      let thenRest = parts.slice(5);

      let val1 = variables[conditionVar1] ?? parseInt(conditionVar1);
      let val2 = variables[conditionVar2] ?? parseInt(conditionVar2);

      let cond = false;
      switch (conditionOp) {
        case ">": cond = val1 > val2; break;
        case "<": cond = val1 < val2; break;
        case "==": cond = val1 == val2; break;
        case "!=": cond = val1 != val2; break;
        case ">=": cond = val1 >= val2; break;
        case "<=": cond = val1 <= val2; break;
      }
      
      if (cond) {
        if (thenCmd === "–ü–ï–†–ï–ô–¢–ò") {
          let label = thenRest[0];
          if (labels[label] !== undefined) {
            currentLine = labels[label];
            return false;
          }
        } else if (thenCmd === "–í–´–í–ï–°–¢–ò") {
          let expr = thenRest.join(" ");
          if (expr.startsWith('"') && expr.endsWith('"')) {
            outputDiv.innerHTML += expr.slice(1, -1) + "<br>";
          } else {
            let val = variables[expr] ?? expr;
            outputDiv.innerHTML += val + "<br>";
          }
        }
      }
    } else if (cmd === "–ï–°–õ–ò_–ù–ê–ñ–ê–¢–ê") {
      if (parts.length < 4) return true;
      let buttonName = parts[1];
      
      if (–∫–Ω–æ–ø–∫–∏–ù–∞–∂–∞—Ç—ã[buttonName]) {
        let thenCmd = parts[2];
        let nextCmd = parts[3];
        let nextRest = parts.slice(4);

        if (nextCmd === "–ü–ï–†–ï–ô–¢–ò") {
          let label = nextRest[0];
          if (labels[label] !== undefined) {
            currentLine = labels[label];
            –∫–Ω–æ–ø–∫–∏–ù–∞–∂–∞—Ç—ã[buttonName] = false;
            return false;
          }
        } else if (nextCmd === "–í–´–í–ï–°–¢–ò") {
          let expr = nextRest.join(" ");
          if (expr.startsWith('"') && expr.endsWith('"')) {
            outputDiv.innerHTML += expr.slice(1, -1) + "<br>";
          } else {
            let val = variables[expr] ?? expr;
            outputDiv.innerHTML += val + "<br>";
          }
          –∫–Ω–æ–ø–∫–∏–ù–∞–∂–∞—Ç—ã[buttonName] = false;
        }
      }
    } else if (cmd === "–ò–ì–†–ê") {
      if (parts.length > 1 && parts[1] === "–£–ì–ê–î–ê–ô") {
        let min = 1;
        let max = 100;
        let secret = Math.floor(Math.random() * (max - min + 1)) + min;
        let attempts = 0;
        let guess = 0;
        
        outputDiv.innerHTML += "–Ø –∑–∞–≥–∞–¥–∞–ª —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ 100. –ü–æ–ø—Ä–æ–±—É–π —É–≥–∞–¥–∞—Ç—å!<br>";
        
        while (guess !== secret) {
          let input = prompt("–í–≤–µ–¥–∏—Ç–µ –≤–∞—à–µ –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏–µ:");
          guess = parseInt(input);
          attempts++;
          
          if (isNaN(guess)) {
            outputDiv.innerHTML += "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ!<br>";
          } else if (guess < secret) {
            outputDiv.innerHTML += "–°–ª–∏—à–∫–æ–º –º–∞–ª–æ! –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.<br>";
          } else if (guess > secret) {
            outputDiv.innerHTML += "–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ! –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.<br>";
          }
        }
        
        outputDiv.innerHTML += `–ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –í—ã —É–≥–∞–¥–∞–ª–∏ —á–∏—Å–ª–æ ${secret} –∑–∞ ${attempts} –ø–æ–ø—ã—Ç–æ–∫.<br>`;
      } else if (parts.length > 1 && parts[1] === "–ö–ù–ë") {
        // –ö–∞–º–µ–Ω—å-–Ω–æ–∂–Ω–∏—Ü—ã-–±—É–º–∞–≥–∞
        const choices = ["–ö–ê–ú–ï–ù–¨", "–ù–û–ñ–ù–ò–¶–´", "–ë–£–ú–ê–ì–ê"];
        const compChoice = choices[Math.floor(Math.random() * 3)];
        
        outputDiv.innerHTML += "–ò–≥—Ä–∞ –ö–∞–º–µ–Ω—å-–ù–æ–∂–Ω–∏—Ü—ã-–ë—É–º–∞–≥–∞!<br>";
        outputDiv.innerHTML += "–í—ã–±–µ—Ä–∏—Ç–µ: –ö–ê–ú–ï–ù–¨, –ù–û–ñ–ù–ò–¶–´ –∏–ª–∏ –ë–£–ú–ê–ì–ê<br>";
        
        let playerChoice = prompt("–í–∞—à –≤—ã–±–æ—Ä:").toUpperCase();
        
        if (!choices.includes(playerChoice)) {
          outputDiv.innerHTML += "–ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä!<br>";
          return true;
        }
        
        outputDiv.innerHTML += `–ö–æ–º–ø—å—é—Ç–µ—Ä –≤—ã–±—Ä–∞–ª: ${compChoice}<br>`;
        outputDiv.innerHTML += `–í—ã –≤—ã–±—Ä–∞–ª–∏: ${playerChoice}<br>`;
        
        if (playerChoice === compChoice) {
          outputDiv.innerHTML += "–ù–∏—á—å—è!<br>";
        } else if (
          (playerChoice === "–ö–ê–ú–ï–ù–¨" && compChoice === "–ù–û–ñ–ù–ò–¶–´") ||
          (playerChoice === "–ù–û–ñ–ù–ò–¶–´" && compChoice === "–ë–£–ú–ê–ì–ê") ||
          (playerChoice === "–ë–£–ú–ê–ì–ê" && compChoice === "–ö–ê–ú–ï–ù–¨")
        ) {
          outputDiv.innerHTML += "–í—ã –ø–æ–±–µ–¥–∏–ª–∏!<br>";
        } else {
          outputDiv.innerHTML += "–ö–æ–º–ø—å—é—Ç–µ—Ä –ø–æ–±–µ–¥–∏–ª!<br>";
        }
      }
    } else if (cmd === "–ó–ê–ì–û–õ–û–í–û–ö") {
      let text = line.slice("–ó–ê–ì–û–õ–û–í–û–ö".length).trim();
      text = text.replace(/^"|"$/g, "");
      uiDiv.innerHTML += `<h2>${text}</h2>`;
    } else if (cmd === "–¢–ï–ö–°–¢") {
      let text = line.slice("–¢–ï–ö–°–¢".length).trim();
      text = text.replace(/^"|"$/g, "");
      uiDiv.innerHTML += `<p>${text}</p>`;
    } else if (cmd === "–ö–ù–û–ü–ö–ê") {
      if (parts.length < 3) return true;
      let name = parts[1];
      let text = parts.slice(2).join(" ").replace(/^"|"$/g, "");
      
      if (!document.getElementById(`btn_${name}`)) {
        let btn = document.createElement("button");
        btn.id = `btn_${name}`;
        btn.textContent = text;
        btn.onclick = () => { 
          –∫–Ω–æ–ø–∫–∏–ù–∞–∂–∞—Ç—ã[name] = true;
          processNextLine();
        };
        uiDiv.appendChild(btn);
      }
    } else if (cmd === "–ü–ï–†–ï–ô–¢–ò") {
      if (parts.length < 2) return true;
      let labelName = parts[1];
      if (labels[labelName] !== undefined) {
        currentLine = labels[labelName];
        return false;
      } else {
        outputDiv.innerHTML += `[–û—à–∏–±–∫–∞: –º–µ—Ç–∫–∞ '${labelName}' –Ω–µ –Ω–∞–π–¥–µ–Ω–∞]<br>`;
      }
    }
    
    // ========== –ù–û–í–´–ï –ö–û–ú–ê–ù–î–´ ==========
    else if (cmd === "–ú–ê–°–°–ò–í") {
      if (parts.length < 2) return true;
      let arrayName = parts[1].replace(/\[.*\]/, '');
      let size = 10; // default size
      
      const sizeMatch = parts[1].match(/\[(\d+)\]/);
      if (sizeMatch) size = parseInt(sizeMatch[1]);
      
      arrays[arrayName] = new Array(size).fill(0);
    }
    else if (cmd === "–ó–ê–ü–ò–°–ê–¢–¨") {
      if (parts.length < 5) return true;
      let arrayName = parts[1].replace(/\[.*\]/, '');
      let index = parseInt(parts[1].match(/\[(\d+)\]/)[1]);
      let value = variables[parts[3]] ?? parseInt(parts[3]);
      
      if (arrays[arrayName] && index >= 0 && index < arrays[arrayName].length) {
        arrays[arrayName][index] = value;
      }
    }
    else if (cmd === "–ü–†–û–ß–ï–°–¢–¨") {
      if (parts.length < 4) return true;
      let arrayName = parts[1].replace(/\[.*\]/, '');
      let index = parseInt(parts[1].match(/\[(\d+)\]/)[1]);
      let resultVar = parts[2];
      
      if (arrays[arrayName] && index >= 0 && index < arrays[arrayName].length) {
        variables[resultVar] = arrays[arrayName][index];
      }
    }
    else if (cmd === "–î–õ–ò–ù–ê") {
      if (parts.length < 3) return true;
      let arrayName = parts[1];
      let resultVar = parts[2];
      
      if (arrays[arrayName]) {
        variables[resultVar] = arrays[arrayName].length;
      }
    }
    else if (cmd === "–û–°–¢–ê–¢–û–ö") {
      if (parts.length < 4) return true;
      let a = variables[parts[1]] ?? parseInt(parts[1]);
      let b = variables[parts[2]] ?? parseInt(parts[2]);
      variables[parts[3]] = a % b;
    }
    else if (cmd === "–°–¢–ï–ü–ï–ù–¨") {
      if (parts.length < 4) return true;
      let a = variables[parts[1]] ?? parseInt(parts[1]);
      let b = variables[parts[2]] ?? parseInt(parts[2]);
      variables[parts[3]] = Math.pow(a, b);
    }
    else if (cmd === "–ü–ê–£–ó–ê") {
      if (parts.length < 2) return true;
      let ms = variables[parts[1]] ?? parseInt(parts[1]);
      await sleep(ms);
    }
    else if (cmd === "–°–õ–£–ß–ê–ô–ù–û–ï_–ß–ò–°–õ–û") {
      if (parts.length < 2) return true;
      variables[parts[1]] = Math.random();
    }
    else if (cmd === "–¢–ï–ö–£–©–ï–ï_–í–†–ï–ú–Ø") {
      if (parts.length < 2) return true;
      variables[parts[1]] = new Date().toLocaleTimeString();
    }
    else if (cmd === "–ü–û–ö–ê") {
      if (parts.length < 4) return true;
      let conditionVar1 = parts[1];
      let conditionOp = parts[2];
      let conditionVar2 = parts[3];
      
      let val1 = variables[conditionVar1] ?? parseInt(conditionVar1);
      let val2 = variables[conditionVar2] ?? parseInt(conditionVar2);
      
      let cond = false;
      switch (conditionOp) {
        case ">": cond = val1 > val2; break;
        case "<": cond = val1 < val2; break;
        case "==": cond = val1 == val2; break;
        case "!=": cond = val1 != val2; break;
        case ">=": cond = val1 >= val2; break;
        case "<=": cond = val1 <= val2; break;
      }
      
      if (!cond) {
        // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Ü–∏–∫–ª
        let depth = 1;
        while (currentLine < rawCode.length - 1 && depth > 0) {
          currentLine++;
          let nextLine = rawCode[currentLine].trim();
          if (nextLine === "–ö–û–ù–ï–¶_–¶–ò–ö–õ–ê") depth--;
          if (nextLine.startsWith("–ü–û–ö–ê ")) depth++;
        }
      }
    }
    else if (cmd === "–ö–û–ù–ï–¶_–¶–ò–ö–õ–ê") {
      // –í–æ–∑–≤—Ä–∞—Ç –∫ –Ω–∞—á–∞–ª—É —Ü–∏–∫–ª–∞
      let depth = 1;
      while (currentLine > 0 && depth > 0) {
        currentLine--;
        let prevLine = rawCode[currentLine].trim();
        if (prevLine === "–ö–û–ù–ï–¶_–¶–ò–ö–õ–ê") depth++;
        if (prevLine.startsWith("–ü–û–ö–ê ")) depth--;
      }
      return false;
    }
    else if (cmd === "–ü–û–õ–ï_–í–í–û–î–ê") {
      if (parts.length < 3) return true;
      let name = parts[1];
      let placeholder = parts.slice(2).join(" ").replace(/^"|"$/g, "");
      
      if (!document.getElementById(`input_${name}`)) {
        let input = document.createElement("input");
        input.id = `input_${name}`;
        input.placeholder = placeholder;
        input.style.margin = "5px";
        input.style.padding = "5px";
        input.onchange = () => variables[name] = input.value;
        uiDiv.appendChild(input);
      }
    }

  } catch (e) {
    outputDiv.innerHTML += `[–û—à–∏–±–∫–∞: ${e.message}]<br>`;
  }

  return true;
}

async function processNextLine() {
  if (!isRunning || currentLine >= rawCode.length) {
    isRunning = false;
    if (executionTimeout) {
      clearTimeout(executionTimeout);
      executionTimeout = null;
    }
    return;
  }

  const line = rawCode[currentLine];
  const shouldContinue = await executeLine(line);
  
  if (shouldContinue) {
    currentLine++;
  }

  if (isRunning && currentLine < rawCode.length) {
    executionTimeout = setTimeout(processNextLine, 10);
  } else {
    isRunning = false;
    if (executionTimeout) {
      clearTimeout(executionTimeout);
      executionTimeout = null;
    }
  }
}

async function runCode() {
  resetInterpreter();
  isRunning = true;
  rawCode = document.getElementById("code").value.toUpperCase().split("\n");
  currentLine = 0;

  // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ –º–µ—Ç–∫–∏
  labels = {};
  for (let idx = 0; idx < rawCode.length; idx++) {
    let l = rawCode[idx].trim();
    if (l.startsWith("–ú–ï–¢–ö–ê ")) {
      const labelParts = parseLine(l);
      if (labelParts.length >= 2) {
        let labelName = labelParts[1];
        labels[labelName] = idx;
      }
    }
  }

  processNextLine();
}

async function openAsSite() {
  resetInterpreter();
  isRunning = true;
  rawCode = document.getElementById("code").value.toUpperCase().split("\n");
  currentLine = 0;

  labels = {};
  for (let idx = 0; idx < rawCode.length; idx++) {
    let l = rawCode[idx].trim();
    if (l.startsWith("–ú–ï–¢–ö–ê ")) {
      const labelParts = parseLine(l);
      if (labelParts.length >= 2) {
        let labelName = labelParts[1];
        labels[labelName] = idx;
      }
    }
  }

  while (currentLine < rawCode.length) {
    const line = rawCode[currentLine].trim();
    const parts = parseLine(line);
    
    if (parts.length > 0 && ["–ó–ê–ì–û–õ–û–í–û–ö", "–¢–ï–ö–°–¢", "–ö–ù–û–ü–ö–ê", "–ü–û–õ–ï_–í–í–û–î–ê"].includes(parts[0])) {
      break;
    }
    currentLine++;
  }

  processNextLine();
}
</script>

</body>
</html>
